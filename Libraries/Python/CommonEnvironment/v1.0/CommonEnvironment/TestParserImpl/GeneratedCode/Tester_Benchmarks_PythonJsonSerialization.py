# --------------------------------------------------------------------------------
# |
# |  WARNING:
# |  This file was generated; any local changes will be overwritten during
# |  future invocations of the generator!
# |
# |  Generated by: <SimpleSchemaGenerator>/Plugins/Impl/PythonSerializationImpl.py
# |  Generated on: 2020-06-04 22:01:50.689365
# |
# --------------------------------------------------------------------------------
import copy
import sys

from collections import OrderedDict

import six

import CommonEnvironment
from CommonEnvironment.TypeInfo import Arity
from CommonEnvironment.TypeInfo.AnyOfTypeInfo import AnyOfTypeInfo
from CommonEnvironment.TypeInfo.ClassTypeInfo import ClassTypeInfo
from CommonEnvironment.TypeInfo.DictTypeInfo import DictTypeInfo
from CommonEnvironment.TypeInfo.GenericTypeInfo import GenericTypeInfo
from CommonEnvironment.TypeInfo.ListTypeInfo import ListTypeInfo

from CommonEnvironment.TypeInfo.FundamentalTypes.Serialization.PythonCodeVisitor import PythonCodeVisitor
from CommonEnvironment.TypeInfo.FundamentalTypes.Serialization.StringSerialization import StringSerialization

# <Unused import> pylint: disable = W0611
# <Unused import> pylint: disable = W0614
from CommonEnvironment.TypeInfo.FundamentalTypes.All import *               # <Wildcard import> pylint: disable = W0401

# <Standard import should be placed before...> pylint: disable = C0411

# ----------------------------------------------------------------------
import json

from CommonEnvironment import FileSystem
from CommonEnvironment.TypeInfo.FundamentalTypes.Serialization.JsonSerialization import JsonSerialization

# ----------------------------------------------------------------------
class JsonEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, Object):
            d = copy.deepcopy(o.__dict__)

            for k in list(six.iterkeys(d)):
                if k.startswith("_"):
                    del d[k]

            return d

        return getattr(o, "__dict__", o)


# ----------------------------------------------------------------------
# <Method name "..." doesn't conform to PascalCase naming style> pylint: disable = C0103
# <Line too long> pylint: disable = C0301
# <Too many lines in module> pylint: disable = C0302
# <Wrong hanging indentation> pylint: disable = C0330

# <Too few public methods> pylint: disable = R0903
# <Too many public methods> pylint: disable = R0904
# <Too many branches> pylint: disable = R0912
# <Too many statements> pylint: disable = R0915


# ----------------------------------------------------------------------
class SerializationException(Exception):
    def __init__(self, ex_or_string):
        if isinstance(ex_or_string, six.string_types):
            super(SerializationException, self).__init__(ex_or_string)
        else:
            super(SerializationException, self).__init__(str(ex_or_string))

            self.__dict__ = copy.deepcopy(ex_or_string.__dict__)


class KeySerializationException(SerializationException):                    pass
class SerializeException(SerializationException):                           pass
class DeserializeException(SerializationException):                         pass


class DoesNotExist(object):                                                 pass


# ----------------------------------------------------------------------
# |
# |  Utility Methods
# |
# ----------------------------------------------------------------------
def Serialize(
    root,
    process_additional_data=False,
    always_include_optional=False,
    to_string=False,
    pretty_print=False,
):
    return Serialize_locations(
        root,
        is_root=False,
        process_additional_data=process_additional_data,
        always_include_optional=always_include_optional,
        to_string=to_string,
        pretty_print=pretty_print,
    )


# ----------------------------------------------------------------------
def Deserialize(
    root,
    process_additional_data=False,
    always_include_optional=False,
):
    return Deserialize_locations(
        root,
        is_root=False,
        process_additional_data=process_additional_data,
        always_include_optional=always_include_optional,
    )


# ----------------------------------------------------------------------
def Serialize_locations(
    items,
    process_additional_data=False,
    always_include_optional=False,
    to_string=False,
    pretty_print=False,
    is_root=False,
):
    """Serializes 'locations' from a python object to a JSON object"""

    if not isinstance(items, list):
        if isinstance(items, dict) and "locations" in items:
            items = items["locations"]
        elif not isinstance(items, dict) and hasattr(items, "locations"):
            items = getattr(items, "locations")
        elif is_root:
            items = DoesNotExist

    try:
        try:
            items = Serializer().locations(
                items,
                process_additional_data=process_additional_data,
                always_include_optional=always_include_optional,
            )

            if items is DoesNotExist:
                items = {}
        except:
            _DecorateActiveException("locations")
    except SerializationException:
        raise
    except Exception as ex:
        raise SerializeException(ex)

    if to_string and items not in [DoesNotExist, None]:
        items = _JsonToString(items, pretty_print)

    return items


# ----------------------------------------------------------------------
def Deserialize_locations(
    items,
    process_additional_data=False,
    always_include_optional=False,
    is_root=False,
):
    """Deserializes 'locations' from a JSON object to a python object"""

    if isinstance(items, six.string_types):
        if FileSystem.IsFilename(items):
            with open(items) as f:
                items = json.load(f)
        else:
            items = json.loads(items)

    if not isinstance(items, list):
        if isinstance(items, dict) and "locations" in items:
            items = items["locations"]
        elif not isinstance(items, dict) and hasattr(items, "locations"):
            items = getattr(items, "locations")
        elif is_root:
            items = DoesNotExist

    try:
        try:
            items = Deserializer().locations(
                items,
                process_additional_data=process_additional_data,
                always_include_optional=always_include_optional,
            )

            if items is DoesNotExist:
                items = {}
        except:
            _DecorateActiveException("locations")
    except SerializationException:
        raise
    except Exception as ex:
        raise DeserializeException(ex)

    return items


# ----------------------------------------------------------------------
# |
# |  Type Infos
# |
# ----------------------------------------------------------------------
locations_TypeInfo                                                          = ClassTypeInfo(OrderedDict([ ( "location_name", StringTypeInfo(min_length=1) ), ( "configurations", ClassTypeInfo(OrderedDict([ ( "configuration_name", StringTypeInfo(min_length=1) ), ( "executables", ClassTypeInfo(OrderedDict([ ( "executable_name", StringTypeInfo(min_length=1) ), ( "values", ClassTypeInfo(OrderedDict([ ( "Name", StringTypeInfo(min_length=1) ), ( "Extractor", StringTypeInfo(min_length=1) ), ( "SourceFilename", StringTypeInfo(min_length=1) ), ( "SourceLine", IntTypeInfo(min=1) ), ( "Min", FloatTypeInfo(min=0.0) ), ( "Max", FloatTypeInfo(min=0.0) ), ( "Mean", FloatTypeInfo(min=0.0) ), ( "StandardDeviation", FloatTypeInfo(min=0.0) ), ( "Samples", IntTypeInfo(min=1) ), ( "Units", StringTypeInfo(min_length=1) ), ( "Iterations", IntTypeInfo(min=1) ) ]), require_exact_match=True, arity=Arity.FromString('+')) ) ]), require_exact_match=True, arity=Arity.FromString('+')) ) ]), require_exact_match=True, arity=Arity.FromString('+')) ) ]), require_exact_match=True, arity=Arity.FromString('*'))

_locations_TypeInfo_Contents                                                = OrderedDict([("location_name", GenericTypeInfo()), ("configurations", GenericTypeInfo(arity=Arity.FromString('+')))])
_locations_configurations_TypeInfo_Contents                                 = OrderedDict([("configuration_name", GenericTypeInfo()), ("executables", GenericTypeInfo(arity=Arity.FromString('+')))])
_locations_configurations_executables_TypeInfo_Contents                     = OrderedDict([("executable_name", GenericTypeInfo()), ("values", GenericTypeInfo(arity=Arity.FromString('+')))])
_locations_configurations_executables_values_TypeInfo_Contents              = OrderedDict([("Name", GenericTypeInfo()), ("Extractor", GenericTypeInfo()), ("SourceFilename", GenericTypeInfo()), ("SourceLine", GenericTypeInfo()), ("Min", GenericTypeInfo()), ("Max", GenericTypeInfo()), ("Mean", GenericTypeInfo()), ("StandardDeviation", GenericTypeInfo()), ("Samples", GenericTypeInfo()), ("Units", GenericTypeInfo()), ("Iterations", GenericTypeInfo())])

_locations_TypeInfo                                                         = AnyOfTypeInfo([ClassTypeInfo(_locations_TypeInfo_Contents, require_exact_match=False), DictTypeInfo(_locations_TypeInfo_Contents, require_exact_match=False)], arity=Arity.FromString('*'))
_locations_location_name_TypeInfo                                           = StringTypeInfo(min_length=1)
_locations_configurations_TypeInfo                                          = AnyOfTypeInfo([ClassTypeInfo(_locations_configurations_TypeInfo_Contents, require_exact_match=False), DictTypeInfo(_locations_configurations_TypeInfo_Contents, require_exact_match=False)], arity=Arity.FromString('+'))
_locations_configurations_configuration_name_TypeInfo                       = StringTypeInfo(min_length=1)
_locations_configurations_executables_TypeInfo                              = AnyOfTypeInfo([ClassTypeInfo(_locations_configurations_executables_TypeInfo_Contents, require_exact_match=False), DictTypeInfo(_locations_configurations_executables_TypeInfo_Contents, require_exact_match=False)], arity=Arity.FromString('+'))
_locations_configurations_executables_executable_name_TypeInfo              = StringTypeInfo(min_length=1)
_locations_configurations_executables_values_TypeInfo                       = AnyOfTypeInfo([ClassTypeInfo(_locations_configurations_executables_values_TypeInfo_Contents, require_exact_match=False), DictTypeInfo(_locations_configurations_executables_values_TypeInfo_Contents, require_exact_match=False)], arity=Arity.FromString('+'))
_locations_configurations_executables_values_Name_TypeInfo                  = StringTypeInfo(min_length=1)
_locations_configurations_executables_values_Extractor_TypeInfo             = StringTypeInfo(min_length=1)
_locations_configurations_executables_values_SourceFilename_TypeInfo        = StringTypeInfo(min_length=1)
_locations_configurations_executables_values_SourceLine_TypeInfo            = IntTypeInfo(min=1)
_locations_configurations_executables_values_Min_TypeInfo                   = FloatTypeInfo(min=0.0)
_locations_configurations_executables_values_Max_TypeInfo                   = FloatTypeInfo(min=0.0)
_locations_configurations_executables_values_Mean_TypeInfo                  = FloatTypeInfo(min=0.0)
_locations_configurations_executables_values_StandardDeviation_TypeInfo     = FloatTypeInfo(min=0.0)
_locations_configurations_executables_values_Samples_TypeInfo               = IntTypeInfo(min=1)
_locations_configurations_executables_values_Units_TypeInfo                 = StringTypeInfo(min_length=1)
_locations_configurations_executables_values_Iterations_TypeInfo            = IntTypeInfo(min=1)

# ----------------------------------------------------------------------
# |
# |  Serializer
# |
# ----------------------------------------------------------------------
class Serializer(object):

    # ----------------------------------------------------------------------
    @classmethod
    def locations(cls, item, always_include_optional, process_additional_data):
        if item in [DoesNotExist, None, {}, OrderedDict]:
            _locations_TypeInfo.ValidateArity(None)
            return DoesNotExist

        if not process_additional_data:
            _locations_TypeInfo.ValidateArity(item)

        result = cls._locations_Item(item, always_include_optional, process_additional_data)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_location_name(cls, item):
        if item in [DoesNotExist, None]:
            _locations_location_name_TypeInfo.ValidateArity(None)
            return DoesNotExist

        _locations_location_name_TypeInfo.ValidateArity(item)

        result = cls._locations_location_name_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations(cls, item, always_include_optional, process_additional_data):
        if item in [DoesNotExist, None, {}, OrderedDict]:
            _locations_configurations_TypeInfo.ValidateArity(None)
            return DoesNotExist

        if not process_additional_data:
            _locations_configurations_TypeInfo.ValidateArity(item)

        result = cls._locations_configurations_Item(item, always_include_optional, process_additional_data)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_configuration_name(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_configuration_name_TypeInfo.ValidateArity(None)
            return DoesNotExist

        _locations_configurations_configuration_name_TypeInfo.ValidateArity(item)

        result = cls._locations_configurations_configuration_name_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables(cls, item, always_include_optional, process_additional_data):
        if item in [DoesNotExist, None, {}, OrderedDict]:
            _locations_configurations_executables_TypeInfo.ValidateArity(None)
            return DoesNotExist

        if not process_additional_data:
            _locations_configurations_executables_TypeInfo.ValidateArity(item)

        result = cls._locations_configurations_executables_Item(item, always_include_optional, process_additional_data)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_executable_name(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_executable_name_TypeInfo.ValidateArity(None)
            return DoesNotExist

        _locations_configurations_executables_executable_name_TypeInfo.ValidateArity(item)

        result = cls._locations_configurations_executables_executable_name_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values(cls, items, always_include_optional, process_additional_data):
        if items in [DoesNotExist, None, []]:
            _locations_configurations_executables_values_TypeInfo.ValidateArity(None)
            return DoesNotExist

        if not process_additional_data:
            _locations_configurations_executables_values_TypeInfo.ValidateArity(items)

        results = []

        for this_index, this_item in enumerate(items or []):
            try:
                results.append(cls._locations_configurations_executables_values_Item(this_item, always_include_optional, process_additional_data))
            except:
                _DecorateActiveException("Index {}".format(this_index))

        return results

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_Name(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_Name_TypeInfo.ValidateArity(None)
            return DoesNotExist

        _locations_configurations_executables_values_Name_TypeInfo.ValidateArity(item)

        result = cls._locations_configurations_executables_values_Name_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_Extractor(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_Extractor_TypeInfo.ValidateArity(None)
            return DoesNotExist

        _locations_configurations_executables_values_Extractor_TypeInfo.ValidateArity(item)

        result = cls._locations_configurations_executables_values_Extractor_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_SourceFilename(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_SourceFilename_TypeInfo.ValidateArity(None)
            return DoesNotExist

        _locations_configurations_executables_values_SourceFilename_TypeInfo.ValidateArity(item)

        result = cls._locations_configurations_executables_values_SourceFilename_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_SourceLine(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_SourceLine_TypeInfo.ValidateArity(None)
            return DoesNotExist

        _locations_configurations_executables_values_SourceLine_TypeInfo.ValidateArity(item)

        result = cls._locations_configurations_executables_values_SourceLine_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_Min(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_Min_TypeInfo.ValidateArity(None)
            return DoesNotExist

        _locations_configurations_executables_values_Min_TypeInfo.ValidateArity(item)

        result = cls._locations_configurations_executables_values_Min_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_Max(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_Max_TypeInfo.ValidateArity(None)
            return DoesNotExist

        _locations_configurations_executables_values_Max_TypeInfo.ValidateArity(item)

        result = cls._locations_configurations_executables_values_Max_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_Mean(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_Mean_TypeInfo.ValidateArity(None)
            return DoesNotExist

        _locations_configurations_executables_values_Mean_TypeInfo.ValidateArity(item)

        result = cls._locations_configurations_executables_values_Mean_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_StandardDeviation(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_StandardDeviation_TypeInfo.ValidateArity(None)
            return DoesNotExist

        _locations_configurations_executables_values_StandardDeviation_TypeInfo.ValidateArity(item)

        result = cls._locations_configurations_executables_values_StandardDeviation_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_Samples(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_Samples_TypeInfo.ValidateArity(None)
            return DoesNotExist

        _locations_configurations_executables_values_Samples_TypeInfo.ValidateArity(item)

        result = cls._locations_configurations_executables_values_Samples_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_Units(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_Units_TypeInfo.ValidateArity(None)
            return DoesNotExist

        _locations_configurations_executables_values_Units_TypeInfo.ValidateArity(item)

        result = cls._locations_configurations_executables_values_Units_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_Iterations(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_Iterations_TypeInfo.ValidateArity(None)
            return DoesNotExist

        _locations_configurations_executables_values_Iterations_TypeInfo.ValidateArity(item)

        result = cls._locations_configurations_executables_values_Iterations_Item(item)

        return result

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    @classmethod
    def _locations_Item(cls, item, always_include_optional, process_additional_data):
        result = OrderedDict()

        for key, value in six.iteritems(item or {}):
            try:
                this_result = cls.locations_configurations(value, always_include_optional, process_additional_data)
                if this_result is DoesNotExist:
                    if always_include_optional:
                        this_result = {}
                    else:
                        continue

                result[cls.locations_location_name(key)] = this_result
            except:
                _DecorateActiveException("Key '{}'".format(key))

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_location_name_Item(cls, item):
        return JsonSerialization.SerializeItem(_locations_location_name_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_Item(cls, item, always_include_optional, process_additional_data):
        result = OrderedDict()

        for key, value in six.iteritems(item or {}):
            try:
                this_result = cls.locations_configurations_executables(value, always_include_optional, process_additional_data)
                if this_result is DoesNotExist:
                    if always_include_optional:
                        this_result = {}
                    else:
                        continue

                result[cls.locations_configurations_configuration_name(key)] = this_result
            except:
                _DecorateActiveException("Key '{}'".format(key))

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_configuration_name_Item(cls, item):
        return JsonSerialization.SerializeItem(_locations_configurations_configuration_name_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_Item(cls, item, always_include_optional, process_additional_data):
        result = OrderedDict()

        for key, value in six.iteritems(item or {}):
            try:
                this_result = cls.locations_configurations_executables_values(value, always_include_optional, process_additional_data)
                if this_result is DoesNotExist:
                    if always_include_optional:
                        this_result = []
                    else:
                        continue

                result[cls.locations_configurations_executables_executable_name(key)] = this_result
            except:
                _DecorateActiveException("Key '{}'".format(key))

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_executable_name_Item(cls, item):
        return JsonSerialization.SerializeItem(_locations_configurations_executables_executable_name_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Item(cls, item, always_include_optional, process_additional_data):
        _locations_configurations_executables_values_TypeInfo.ValidateItem(
            item,
            recurse=False,
            require_exact_match=not process_additional_data,
        )

        result = _CreatePythonObject(
            attributes=None,
        )

        # Name
        try:
            setattr(result, "Name", cls.locations_configurations_executables_values_Name(
                cls._GetPythonAttribute(
                    item,
                    "Name",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("Name")

        # Extractor
        try:
            setattr(result, "Extractor", cls.locations_configurations_executables_values_Extractor(
                cls._GetPythonAttribute(
                    item,
                    "Extractor",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("Extractor")

        # SourceFilename
        try:
            setattr(result, "SourceFilename", cls.locations_configurations_executables_values_SourceFilename(
                cls._GetPythonAttribute(
                    item,
                    "SourceFilename",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("SourceFilename")

        # SourceLine
        try:
            setattr(result, "SourceLine", cls.locations_configurations_executables_values_SourceLine(
                cls._GetPythonAttribute(
                    item,
                    "SourceLine",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("SourceLine")

        # Min
        try:
            setattr(result, "Min", cls.locations_configurations_executables_values_Min(
                cls._GetPythonAttribute(
                    item,
                    "Min",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("Min")

        # Max
        try:
            setattr(result, "Max", cls.locations_configurations_executables_values_Max(
                cls._GetPythonAttribute(
                    item,
                    "Max",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("Max")

        # Mean
        try:
            setattr(result, "Mean", cls.locations_configurations_executables_values_Mean(
                cls._GetPythonAttribute(
                    item,
                    "Mean",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("Mean")

        # StandardDeviation
        try:
            setattr(result, "StandardDeviation", cls.locations_configurations_executables_values_StandardDeviation(
                cls._GetPythonAttribute(
                    item,
                    "StandardDeviation",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("StandardDeviation")

        # Samples
        try:
            setattr(result, "Samples", cls.locations_configurations_executables_values_Samples(
                cls._GetPythonAttribute(
                    item,
                    "Samples",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("Samples")

        # Units
        try:
            setattr(result, "Units", cls.locations_configurations_executables_values_Units(
                cls._GetPythonAttribute(
                    item,
                    "Units",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("Units")

        # Iterations
        try:
            setattr(result, "Iterations", cls.locations_configurations_executables_values_Iterations(
                cls._GetPythonAttribute(
                    item,
                    "Iterations",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("Iterations")

        # Additional data
        if process_additional_data:
            cls._ApplyAdditionalData(
                item,
                result,
                exclude_names={"Name", "Extractor", "SourceFilename", "SourceLine", "Min", "Max", "Mean", "StandardDeviation", "Samples", "Units", "Iterations"},
            )

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Name_Item(cls, item):
        return JsonSerialization.SerializeItem(_locations_configurations_executables_values_Name_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Extractor_Item(cls, item):
        return JsonSerialization.SerializeItem(_locations_configurations_executables_values_Extractor_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_SourceFilename_Item(cls, item):
        return JsonSerialization.SerializeItem(_locations_configurations_executables_values_SourceFilename_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_SourceLine_Item(cls, item):
        return JsonSerialization.SerializeItem(_locations_configurations_executables_values_SourceLine_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Min_Item(cls, item):
        return JsonSerialization.SerializeItem(_locations_configurations_executables_values_Min_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Max_Item(cls, item):
        return JsonSerialization.SerializeItem(_locations_configurations_executables_values_Max_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Mean_Item(cls, item):
        return JsonSerialization.SerializeItem(_locations_configurations_executables_values_Mean_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_StandardDeviation_Item(cls, item):
        return JsonSerialization.SerializeItem(_locations_configurations_executables_values_StandardDeviation_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Samples_Item(cls, item):
        return JsonSerialization.SerializeItem(_locations_configurations_executables_values_Samples_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Units_Item(cls, item):
        return JsonSerialization.SerializeItem(_locations_configurations_executables_values_Units_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Iterations_Item(cls, item):
        return JsonSerialization.SerializeItem(_locations_configurations_executables_values_Iterations_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    @classmethod
    def _ApplyAdditionalData(
        cls,
        source,
        dest,
        exclude_names,
    ):
        for name, child in [(k, v) for k, v in six.iteritems(source if isinstance(source, dict) else getattr(source, "__dict__", {})) if not k.startswith("_") and k not in exclude_names]:
            try:
                if isinstance(child, list):
                    children = []

                    for index, item in enumerate(child):
                        item_name = "Index {}".format(index)

                        try:
                            children.append(cls._CreateAdditionalDataItem(item_name, item))
                        except:
                            _DecorateActiveException(item_name)

                    setattr(dest, name, children)
                else:
                    setattr(dest, name, cls._CreateAdditionalDataItem(name, child))
            except:
                _DecorateActiveException(name)

    # ----------------------------------------------------------------------
    @classmethod
    def _RejectAdditionalData(cls, source, exclude_names):
        errors = []

        for name, child in [(k, v) for k, v in six.iteritems(source if isinstance(source, dict) else getattr(source, "__dict__", {})) if not k.startswith("_") and k not in exclude_names]:
            errors.append(name)

        if errors:
            raise Exception("The item contains unexpected children: {}".format(", ".join(['"{}"'.format(error) for error in errors])))

    # ----------------------------------------------------------------------
    @classmethod
    def _CreateAdditionalDataItem(cls, name, source):
        # The following types should be returned directly without additional conversion
        if isinstance(source, (int, float, str, bool)):
            return source

        assert not isinstance(source, list), source

        if not isinstance(source, dict):
            source = source.__dict__

        source_attribute_names = source.get("_attribute_names", set())

        attributes = OrderedDict()
        items = OrderedDict()

        for k, v in six.iteritems(source):
            if k.startswith("_"):
                continue

            if k in source_attribute_names:
                attributes[k] = v
            else:
                items[k] = v

        if len(items) == 1 and next(six.iterkeys(items)) == source.get("_text_attribute_name", None):
            return _CreatePythonObject(
                attributes=attributes,
                **{"simple_value": source[source["_text_attribute_name"]], "_text_attribute_name": "simple_value"},
            )

        result = _CreatePythonObject(
            attributes=attributes,
        )

        for k, v in six.iteritems(items):
            try:
                if isinstance(v, list):
                    new_items = []

                    for index, child in enumerate(v):
                        try:
                            new_items.append(cls._CreateAdditionalDataItem("item", child))
                        except:
                            _DecorateActiveException("Index {}".format(index))

                    setattr(result, k, new_items)
                else:
                    new_item = cls._CreateAdditionalDataItem(k, v)

                    setattr(result, k, new_item)
            except:
                _DecorateActiveException(k)

        return result

    # ----------------------------------------------------------------------
    @staticmethod
    def _GetPythonAttribute(
        item,
        attribute_name,
        is_optional=False,
    ):
        if not isinstance(item, dict):
            if hasattr(item, "__dict__"):
                item = item.__dict__
            else:
                item = {}

        value = item.get(attribute_name, DoesNotExist)
        if value is DoesNotExist and not is_optional:
            raise SerializeException("No items were found")

        return value


# ----------------------------------------------------------------------
class Object(object):
    def __init__(self):
        self._attribute_names = set()

    def __repr__(self):
        return CommonEnvironment.ObjectReprImpl(self)


# ----------------------------------------------------------------------
def _CreatePythonObject(
    attributes=None,
    **kwargs
):
    attributes = attributes or {}

    result = Object()

    for d in [attributes, kwargs]:
        for k, v in six.iteritems(d):
            setattr(result, k, v)

    for k in six.iterkeys(attributes):
        result._attribute_names.add(k)

    return result


# ----------------------------------------------------------------------
def _JsonToString(obj, pretty_print):
    if pretty_print:
        content = json.dumps(obj, cls=JsonEncoder, indent=2, separators=[", ", " : "])

        # Remove trailing whitespace
        return "\n".join([line.rstrip() for line in content.split("\n")])

    else:
        return json.dumps(obj, cls=JsonEncoder)


# ----------------------------------------------------------------------
# |
# |  Deserializer
# |
# ----------------------------------------------------------------------
class Deserializer(object):

    # ----------------------------------------------------------------------
    @classmethod
    def locations(cls, item, always_include_optional, process_additional_data):
        if item in [DoesNotExist, None, {}, OrderedDict]:
            _locations_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_Item(item, always_include_optional, process_additional_data)

        if not process_additional_data:
            _locations_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_location_name(cls, item):
        if item in [DoesNotExist, None]:
            _locations_location_name_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_location_name_Item(item)

        _locations_location_name_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations(cls, item, always_include_optional, process_additional_data):
        if item in [DoesNotExist, None, {}, OrderedDict]:
            _locations_configurations_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_configurations_Item(item, always_include_optional, process_additional_data)

        if not process_additional_data:
            _locations_configurations_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_configuration_name(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_configuration_name_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_configurations_configuration_name_Item(item)

        _locations_configurations_configuration_name_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables(cls, item, always_include_optional, process_additional_data):
        if item in [DoesNotExist, None, {}, OrderedDict]:
            _locations_configurations_executables_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_configurations_executables_Item(item, always_include_optional, process_additional_data)

        if not process_additional_data:
            _locations_configurations_executables_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_executable_name(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_executable_name_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_configurations_executables_executable_name_Item(item)

        _locations_configurations_executables_executable_name_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values(cls, items, always_include_optional, process_additional_data):
        if items in [DoesNotExist, None, []]:
            _locations_configurations_executables_values_TypeInfo.ValidateArity(None)
            return DoesNotExist

        results = []

        for this_index, this_item in enumerate(items or []):
            try:
                results.append(cls._locations_configurations_executables_values_Item(this_item, always_include_optional, process_additional_data))
            except:
                _DecorateActiveException("Index {}".format(this_index))

        if not process_additional_data:
            _locations_configurations_executables_values_TypeInfo.ValidateArity(results)

        return results

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_Name(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_Name_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_configurations_executables_values_Name_Item(item)

        _locations_configurations_executables_values_Name_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_Extractor(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_Extractor_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_configurations_executables_values_Extractor_Item(item)

        _locations_configurations_executables_values_Extractor_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_SourceFilename(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_SourceFilename_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_configurations_executables_values_SourceFilename_Item(item)

        _locations_configurations_executables_values_SourceFilename_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_SourceLine(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_SourceLine_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_configurations_executables_values_SourceLine_Item(item)

        _locations_configurations_executables_values_SourceLine_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_Min(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_Min_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_configurations_executables_values_Min_Item(item)

        _locations_configurations_executables_values_Min_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_Max(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_Max_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_configurations_executables_values_Max_Item(item)

        _locations_configurations_executables_values_Max_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_Mean(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_Mean_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_configurations_executables_values_Mean_Item(item)

        _locations_configurations_executables_values_Mean_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_StandardDeviation(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_StandardDeviation_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_configurations_executables_values_StandardDeviation_Item(item)

        _locations_configurations_executables_values_StandardDeviation_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_Samples(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_Samples_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_configurations_executables_values_Samples_Item(item)

        _locations_configurations_executables_values_Samples_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_Units(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_Units_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_configurations_executables_values_Units_Item(item)

        _locations_configurations_executables_values_Units_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def locations_configurations_executables_values_Iterations(cls, item):
        if item in [DoesNotExist, None]:
            _locations_configurations_executables_values_Iterations_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._locations_configurations_executables_values_Iterations_Item(item)

        _locations_configurations_executables_values_Iterations_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    @classmethod
    def _locations_Item(cls, item, always_include_optional, process_additional_data):
        result = OrderedDict()

        for key, value in six.iteritems(item or {}):
            try:
                this_result = cls.locations_configurations(value, always_include_optional, process_additional_data)
                if this_result is DoesNotExist:
                    if always_include_optional:
                        this_result = {}
                    else:
                        continue

                result[cls.locations_location_name(key)] = this_result
            except:
                _DecorateActiveException("Key '{}'".format(key))

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_location_name_Item(cls, item):
        return JsonSerialization.DeserializeItem(_locations_location_name_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_Item(cls, item, always_include_optional, process_additional_data):
        result = OrderedDict()

        for key, value in six.iteritems(item or {}):
            try:
                this_result = cls.locations_configurations_executables(value, always_include_optional, process_additional_data)
                if this_result is DoesNotExist:
                    if always_include_optional:
                        this_result = {}
                    else:
                        continue

                result[cls.locations_configurations_configuration_name(key)] = this_result
            except:
                _DecorateActiveException("Key '{}'".format(key))

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_configuration_name_Item(cls, item):
        return JsonSerialization.DeserializeItem(_locations_configurations_configuration_name_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_Item(cls, item, always_include_optional, process_additional_data):
        result = OrderedDict()

        for key, value in six.iteritems(item or {}):
            try:
                this_result = cls.locations_configurations_executables_values(value, always_include_optional, process_additional_data)
                if this_result is DoesNotExist:
                    if always_include_optional:
                        this_result = []
                    else:
                        continue

                result[cls.locations_configurations_executables_executable_name(key)] = this_result
            except:
                _DecorateActiveException("Key '{}'".format(key))

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_executable_name_Item(cls, item):
        return JsonSerialization.DeserializeItem(_locations_configurations_executables_executable_name_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Item(cls, item, always_include_optional, process_additional_data):
        result = _CreatePythonObject(
            attributes=None,
        )

        # Name
        try:
            setattr(result, "Name", cls.locations_configurations_executables_values_Name(
                cls._GetPythonAttribute(
                    item,
                    "Name",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("Name")

        # Extractor
        try:
            setattr(result, "Extractor", cls.locations_configurations_executables_values_Extractor(
                cls._GetPythonAttribute(
                    item,
                    "Extractor",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("Extractor")

        # SourceFilename
        try:
            setattr(result, "SourceFilename", cls.locations_configurations_executables_values_SourceFilename(
                cls._GetPythonAttribute(
                    item,
                    "SourceFilename",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("SourceFilename")

        # SourceLine
        try:
            setattr(result, "SourceLine", cls.locations_configurations_executables_values_SourceLine(
                cls._GetPythonAttribute(
                    item,
                    "SourceLine",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("SourceLine")

        # Min
        try:
            setattr(result, "Min", cls.locations_configurations_executables_values_Min(
                cls._GetPythonAttribute(
                    item,
                    "Min",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("Min")

        # Max
        try:
            setattr(result, "Max", cls.locations_configurations_executables_values_Max(
                cls._GetPythonAttribute(
                    item,
                    "Max",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("Max")

        # Mean
        try:
            setattr(result, "Mean", cls.locations_configurations_executables_values_Mean(
                cls._GetPythonAttribute(
                    item,
                    "Mean",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("Mean")

        # StandardDeviation
        try:
            setattr(result, "StandardDeviation", cls.locations_configurations_executables_values_StandardDeviation(
                cls._GetPythonAttribute(
                    item,
                    "StandardDeviation",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("StandardDeviation")

        # Samples
        try:
            setattr(result, "Samples", cls.locations_configurations_executables_values_Samples(
                cls._GetPythonAttribute(
                    item,
                    "Samples",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("Samples")

        # Units
        try:
            setattr(result, "Units", cls.locations_configurations_executables_values_Units(
                cls._GetPythonAttribute(
                    item,
                    "Units",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("Units")

        # Iterations
        try:
            setattr(result, "Iterations", cls.locations_configurations_executables_values_Iterations(
                cls._GetPythonAttribute(
                    item,
                    "Iterations",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("Iterations")

        # Additional data
        if process_additional_data:
            cls._ApplyAdditionalData(
                item,
                result,
                exclude_names={"Name", "Extractor", "SourceFilename", "SourceLine", "Min", "Max", "Mean", "StandardDeviation", "Samples", "Units", "Iterations"},
            )

        else:
            cls._RejectAdditionalData(
                item,
                exclude_names=["Name", "Extractor", "SourceFilename", "SourceLine", "Min", "Max", "Mean", "StandardDeviation", "Samples", "Units", "Iterations"],
            )

        _locations_configurations_executables_values_TypeInfo.ValidateItem(
            result,
            recurse=False,
            require_exact_match=not process_additional_data,
        )

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Name_Item(cls, item):
        return JsonSerialization.DeserializeItem(_locations_configurations_executables_values_Name_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Extractor_Item(cls, item):
        return JsonSerialization.DeserializeItem(_locations_configurations_executables_values_Extractor_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_SourceFilename_Item(cls, item):
        return JsonSerialization.DeserializeItem(_locations_configurations_executables_values_SourceFilename_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_SourceLine_Item(cls, item):
        return JsonSerialization.DeserializeItem(_locations_configurations_executables_values_SourceLine_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Min_Item(cls, item):
        return JsonSerialization.DeserializeItem(_locations_configurations_executables_values_Min_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Max_Item(cls, item):
        return JsonSerialization.DeserializeItem(_locations_configurations_executables_values_Max_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Mean_Item(cls, item):
        return JsonSerialization.DeserializeItem(_locations_configurations_executables_values_Mean_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_StandardDeviation_Item(cls, item):
        return JsonSerialization.DeserializeItem(_locations_configurations_executables_values_StandardDeviation_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Samples_Item(cls, item):
        return JsonSerialization.DeserializeItem(_locations_configurations_executables_values_Samples_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Units_Item(cls, item):
        return JsonSerialization.DeserializeItem(_locations_configurations_executables_values_Units_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _locations_configurations_executables_values_Iterations_Item(cls, item):
        return JsonSerialization.DeserializeItem(_locations_configurations_executables_values_Iterations_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    @classmethod
    def _ApplyAdditionalData(
        cls,
        source,
        dest,
        exclude_names,
    ):
        for name, child in [(k, v) for k, v in six.iteritems(source if isinstance(source, dict) else getattr(source, "__dict__", {})) if not k.startswith("_") and k not in exclude_names]:
            try:
                if isinstance(child, list):
                    children = []

                    for index, item in enumerate(child):
                        item_name = "Index {}".format(index)

                        try:
                            children.append(cls._CreateAdditionalDataItem(item_name, item))
                        except:
                            _DecorateActiveException(item_name)

                    setattr(dest, name, children)
                else:
                    setattr(dest, name, cls._CreateAdditionalDataItem(name, child))
            except:
                _DecorateActiveException(name)

    # ----------------------------------------------------------------------
    @classmethod
    def _RejectAdditionalData(cls, source, exclude_names):
        errors = []

        for name, child in [(k, v) for k, v in six.iteritems(source if isinstance(source, dict) else getattr(source, "__dict__", {})) if not k.startswith("_") and k not in exclude_names]:
            errors.append(name)

        if errors:
            raise Exception("The item contains unexpected children: {}".format(", ".join(['"{}"'.format(error) for error in errors])))

    # ----------------------------------------------------------------------
    @classmethod
    def _CreateAdditionalDataItem(cls, name, source):
        # The following types should be returned directly without additional conversion
        if isinstance(source, (int, float, str, bool)):
            return source

        assert not isinstance(source, list), source

        if not isinstance(source, dict):
            source = source.__dict__

        source_attribute_names = source.get("_attribute_names", set())

        attributes = OrderedDict()
        items = OrderedDict()

        for k, v in six.iteritems(source):
            if k.startswith("_"):
                continue

            if k in source_attribute_names:
                attributes[k] = v
            else:
                items[k] = v

        if len(items) == 1 and next(six.iterkeys(items)) == source.get("_text_attribute_name", None):
            return _CreatePythonObject(
                attributes=attributes,
                **{"simple_value": source[source["_text_attribute_name"]], "_text_attribute_name": "simple_value"},
            )

        result = _CreatePythonObject(
            attributes=attributes,
        )

        for k, v in six.iteritems(items):
            try:
                if isinstance(v, list):
                    new_items = []

                    for index, child in enumerate(v):
                        try:
                            new_items.append(cls._CreateAdditionalDataItem("item", child))
                        except:
                            _DecorateActiveException("Index {}".format(index))

                    setattr(result, k, new_items)
                else:
                    new_item = cls._CreateAdditionalDataItem(k, v)

                    setattr(result, k, new_item)
            except:
                _DecorateActiveException(k)

        return result

    # ----------------------------------------------------------------------
    @staticmethod
    def _GetPythonAttribute(
        item,
        attribute_name,
        is_optional=False,
    ):
        if not isinstance(item, dict):
            if hasattr(item, "__dict__"):
                item = item.__dict__
            else:
                item = {}

        value = item.get(attribute_name, DoesNotExist)
        if value is DoesNotExist and not is_optional:
            raise SerializeException("No items were found")

        return value


# ----------------------------------------------------------------------
class Object(object):
    def __init__(self):
        self._attribute_names = set()

    def __repr__(self):
        return CommonEnvironment.ObjectReprImpl(self)


# ----------------------------------------------------------------------
def _CreatePythonObject(
    attributes=None,
    **kwargs
):
    attributes = attributes or {}

    result = Object()

    for d in [attributes, kwargs]:
        for k, v in six.iteritems(d):
            setattr(result, k, v)

    for k in six.iterkeys(attributes):
        result._attribute_names.add(k)

    return result


# ----------------------------------------------------------------------
class Object(object):
    def __init__(self):
        self._attribute_names = set()

    def __repr__(self):
        return CommonEnvironment.ObjectReprImpl(self)


# ----------------------------------------------------------------------
def _CreatePythonObject(
    attributes=None,
    **kwargs
):
    attributes = attributes or {}

    result = Object()

    for d in [attributes, kwargs]:
        for k, v in six.iteritems(d):
            setattr(result, k, v)

    for k in six.iterkeys(attributes):
        result._attribute_names.add(k)

    return result


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
def _DecorateActiveException(frame_desc):
    exception = sys.exc_info()[1]

    if not hasattr(exception, "stack"):
        setattr(exception, "stack", [])

    exception.stack.insert(0, frame_desc)

    # <The raise statement is not inside an except clause> pylint: disable = E0704
    raise
